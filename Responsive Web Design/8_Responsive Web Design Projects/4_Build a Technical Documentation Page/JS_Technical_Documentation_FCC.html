<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link href="JS_Technical_Documentation_FCC.css" rel="stylesheet" type="text/css" />
</head>
<body>
  <nav id="navbar">
    <header  class="gradient">JS Documentation</header>
    <ul>
      <li>
        <a class="nav-link" href="#Introduction">Introduction</a>
      </li>
  
      <li>
        <a class="nav-link" href="#What_you_should_already_know">What you should already know</a>
      </li>
  
      <li>
        <a class="nav-link" href="#Execution_Context">Execution Context</a>
      </li>
  
      <li>
        <a class="nav-link" href="#How_JS_is_executed_&_Call_Stack">How JS is executed & Call Stack</a>
      </li>
  
      <li>
        <a class="nav-link" href="#Hoisting_in_JavaScript_(variables_&_functions)">Hoisting in JavaScript (variables & functions)</a>
      </li>
  
      <li>
        <a class="nav-link" href="#Functions_and_Variable_Environments">Functions and Variable Environments</a>
      </li>
      
      <li>
        <a class="nav-link" href="#Shortest_JS_Program,_window_&_this_keyword">Shortest JS Program, window & this keyword</a>
      </li>
      
      <li>
        <a class="nav-link" href="#Undefined_vs_not_defined_in_JS">Undefined vs not defined in JS</a>
      </li>
      
      <li>
        <a class="nav-link" href="#The_Scope_Chain,_Scope_&_Lexical_Environment">The Scope Chain, Scope & Lexical Environment</a>
      </li>
      
      <li>
        <a class="nav-link" href="#let_&_const_in_JS,_Temporal_Dead_Zone">let & const in JS, Temporal Dead Zone</a>
      </li>
      
      <li>
        <a class="nav-link" href="#Block_Scope_&_Shadowing_in_JS">Block Scope & Shadowing in JS</a>
      </li>
      
      <li>
        <a class="nav-link" href="#Closures_in_JS">Closures in JS</a>
      </li>
      
      <li>
        <a class="nav-link" href="#setTimeout_+_Closures_Interview_Question">setTimeout + Closures Interview Question</a>
      </li>
      
      <li>
        <a class="nav-link" href="#Famous_Interview_Questions_ft._Closures">Famous Interview Questions ft. Closures</a>
      </li>
      
      <li>
        <a class="nav-link" href="#First_Class_Functions_ft._Anonymous_Functions">First Class Functions ft. Anonymous Functions</a>
      </li>
      
      <li>
        <a class="nav-link" href="#Callback_Functions_in_JS_ft._Event_Listeners">Callback Functions in JS ft. Event Listeners</a>
      </li>
      
      <li>
        <a class="nav-link" href="#Asynchronous_JavaScript_&_EVENT_LOOP_from_scratch">Asynchronous JavaScript & EVENT LOOP from scratch</a>
      </li>
      
      <li>
        <a class="nav-link" href="#JS_Engine_Exposed,_Google's_V8_Architecture">JS Engine Exposed, Google's V8 Architecture</a>
      </li>
      
      <li>
        <a class="nav-link" href="#Trust_issues_with_setTimeout()">Trust issues with setTimeout()</a>
      </li>
      
      <li>
        <a class="nav-link" href="#Higher_Order_Functions_ft._Functional_Programming">Higher Order Functions ft. Functional Programming</a>
      </li>
      
      <li>
        <a class="nav-link" href="#map,_filter_&_reduce">map, filter & reduce</a>
      </li>
    </ul>
  </nav>
  
  <main id="main-doc">
    <section class="main-section" id="Introduction">
      <header>Introduction</header>
      <article>
        <p>
          JavaScript is a cross-platform, object-oriented scripting language. It
          is a small and lightweight language. Inside a host environment (for
          example, a web browser), JavaScript can be connected to the objects of
          its environment to provide programmatic control over them.
        </p>
  
        <p>
          JavaScript contains a standard library of objects, such as Array, Date,
          and Math, and a core set of language elements such as operators, control
          structures, and statements. Core JavaScript can be extended for a
          variety of purposes by supplementing it with additional objects; for
          example:
        </p>
  
        <ul>
          <li>
            Client-side JavaScript extends the core language by supplying objects
            to control a browser and its Document Object Model (DOM). For example,
            client-side extensions allow an application to place elements on an
            HTML form and respond to user events such as mouse clicks, form input,
            and page navigation.
          </li>
  
          <li>
            Server-side JavaScript extends the core language by supplying objects
            relevant to running JavaScript on a server. For example, server-side
            extensions allow an application to communicate with a database,
            provide continuity of information from one invocation to another of
            the application, or perform file manipulations on a server.
          </li>
        </ul>
      </article>
    </section>
  
    <section class="main-section" id="What_you_should_already_know">
      <header>What you should already know</header>
      <article>
        <p>
          This guide assumes you have the following basic background:
        </p>
        <ul>
          <li>
            A general understanding of the Internet and the World Wide Web (WWW).
          </li>
          <li>Good working knowledge of HyperText Markup Language (HTML).</li>
          <li>
            Some programming experience.
          </li>
        </ul>
      </article>
  
      <section class="main-section" id="Execution_Context">
        <header>Execution Context</header>
        <article>
          <p>
            Everything in JS happens inside the execution context. Imagine a sealed-off container inside which JS runs. It is an abstract concept that hold info about the env. within the current code is being executed.
          </p>
  
  <a href="https://youtu.be/ZvbzSrg0afE?t=131" target="_blank"><img class="image" src="https://i.postimg.cc/X7LNTZbL/Execution-Context.png" alt="Execution-Context"/></a>
          <!--          IMG-->
  
          <ul>
            <li>
              In the container the first component is memory component and the 2nd one is code component.
            </li>
  
            <li>
              Memory component has all the variables and functions in key value pairs. It is also called Variable environment.
            </li>
  
            <li>
              Code component is the place where code is executed one line at a time. It is also called the Thread of Execution.
            </li>
  
            <li>
              JS is a synchronous, single-threaded language
              <ul>
                <li>
                  Synchronous:- One command at a time.
                </li>
  
                <li>
                  Single-threaded:- In a specific synchronous order.
                </li>
              </ul>
            </li>
          </ul>
        </article>
      </section>
  
      <section class="main-section" id="How_JS_is_executed_&_Call_Stack">
        <header>How JS is executed & Call Stack</header>
        <article>
          <p>
            When a JS program is ran, a global execution context is created. The execution context is created in two phases. First Memory creation phase where JS will allocate memory to variables and functions and other Code execution phase.
          </p>
  
          <ul>
            <li>
              Let's consider the below example and its code execution steps:    
            </li>
          </ul>
  
          <code
            >var n = 2;
            function square(num) {
            var ans = num * num;
            return ans;
            }
            var square2 = square(n);
            var square4 = square(4);
          </code>
  
          <p>
            The very first thing which JS does is memory creation phase, so it goes to line one of above code snippet, and allocates a memory space for variable 'n' and then goes to line two, and allocates a memory space for function 'square'. When allocating memory for n it stores 'undefined', a special value for 'n'. For 'square', it stores the whole code of the function inside its memory space. Then, as square2 and square4 are variables as well, it allocates memory and stores 'undefined' for them, and this is the end of first phase i.e. memory creation phase.
            <br>
            So O/P will look something like:
          </p>
  
  <a href="https://youtu.be/iLWTnMzWtj4?t=80" target="_blank"><img class="image" src="https://i.postimg.cc/BvLqLM17/How-JS-is-executed-Call-Stack-1.png" alt="How-JS-is-executed-Call-Stack-1"/></a>
          <!--          img-->
  
          <p>
            Now, in 2nd phase i.e. code execution phase, it starts going through the whole code line by line. As it encounters var n = 2, it assigns 2 to 'n'. Until now, the value of 'n' was undefined. For function, there is nothing to execute. As these lines were already dealt with in memory creation phase.<br>
            Coming to line 6 i.e. var square2 = square(n), here functions are a bit different than any other language. A new execution context is created altogether. Again in this new execution context, in memory creation phase, we allocate memory to num and ans the two variables. And undefined is placed in them. Now, in code execution phase of this execution context, first 2 is assigned to num. Then var ans = num * num will store 4 in ans. After that, return ans returns the control of program back to where this function was invoked from.
          </p>
  
          <a href="https://youtu.be/iLWTnMzWtj4?t=356" target="_blank"><img class="image" src="https://i.postimg.cc/tTFpDJkh/How-JS-is-executed-Call-Stack-2.png" alt="How-JS-is-executed-Call-Stack-2"/></a>
          <!--Img          -->
  
          <p>
            When return keyword is encountered, It returns the control to the called line and also the function execution context is deleted. Same thing will be repeated for square4 and then after that is finished, the global execution context will be destroyed. So the final diagram before deletion would look something like:
          </p>
  
          <a href="https://youtu.be/iLWTnMzWtj4?t=675" target="_blank"><img class="image" src="https://i.postimg.cc/br885PV4/How-JS-is-executed-Call-Stack-3.png" alt="How-JS-is-executed-Call-Stack-3"/></a>
          <!--         img -->
  
          <ul>
            <li>
              Javascript manages code execution context creation and deletion with the the help of Call Stack.
            </li>
  
            <li>
              Call Stack is a mechanism to keep track of its place in script that calls multiple function. Call Stack maintains the order of execution of execution contexts.
            </li>
  
            <li>
              It is also known as Program Stack, Control Stack, Runtime stack, Machine Stack, Execution context stack.
            </li>
          </ul>
        </article>
      </section>
  
      <section class="main-section" id="Hoisting_in_JavaScript_(variables_&_functions)">
        <header>Hoisting in JavaScript (variables & functions)</header>
        <article>
          <ul>
            <li>
              Let's observe the below code and it's explaination:
            </li>
  
            <code
              >getName(); //Javascript
              console.log(x); // undefined
              var x = 7;
              function getName() {
              console.log("Javascript");
              }
            </code>
  
            <li>
              It should have been an outright error in many other languages, as it is not possible to even access something which is not even created (defined) yet But in JS, We know that in memory creation phase it assigns undefined and puts the content of function to function's memory. And in execution, it then executes whatever is asked. Here, as execution goes line by line and not after compiling, it could only print undefined and nothing else. This phenomenon, is not an error. However, if we remove var x = 7; then it gives error. Uncaught ReferenceError: x is not defined.
            </li>
  
            <li>
              <b>Hoisting:</b> is a concept which enables us to extract values of variables and functions even before initialising/assigning value without getting error and this is happening due to the 1st phase (memory creation phase) of the Execution Context.
            </li>
  
            <li>
              we learnt that execution context gets created in two phase, so even before code execution, memory is created so in case of variable, it will be initialized as undefined while in case of function the whole function code is placed in the memory. Example:
            </li>
  
            <code
              >getName(); // JavaScript
              console.log(x); // undefined
              console.log(getName); // f getName(){ console.log("JavaScript); }
              function getName(){
              console.log("JavaScript");
              }
            </code>
  
            <li>
              Now let's observe a different example and try to understand the output.
            </li>
  
            <code
              >getName(); // Uncaught TypeError: getName is not a function
              console.log(getName);
              var getName = function () {
              console.log("Namaste JavaScript");
              }
              // The code won't execute as the first line itself throws an TypeError.
            </code>
          </ul>
        </article>
      </section>
  
      <section class="main-section" id="Functions_and_Variable_Environments">
        <header>Functions and Variable Environments</header>
        <article>
          <code
            >var x = 1;
            a();
            b(); // we are calling the functions before defining them. This will work
            properly, as seen in Hoisting.
            console.log(x);
            function a() {
            var x = 10; // local scope because of separate execution context
            console.log(x);
            }
            function b() {
            var x = 100;
            console.log(x);
            }
          </code>
  
          <ul>
            <li>Output:</li>
            <ul>
              <li>10</li>
              <li>100</li>
              <li>1</li>
            </ul>
          </ul>
  
          <h2>Code Flow in terms of Execution Context</h2>
          <ul>
            <li>
              The Global Execution Context (GEC) is created (the big box with Memory and Code subparts). Also GEC is pushed into Call Stack.
            </li>
            
            <p>Call Stack : GEC</p>
            
            <li>
              In first phase of GEC (memory phase), variable x:undefined and a and b have their entire function code as value initialized.
            </li>
            
            <li>
              In second phase of GEC (execution phase), when the function is called, a new local Execution Context is created. After x = 1 assigned to GEC x, a() is called. So local EC for a is made inside code part of GEC.
            </li>
            
            <p>Call Stack: [GEC, a()]</p>
            
            <li>
              For local EC, a totally different x variable assigned undefined(x inside a()) in phase 1 , and in phase 2 it is assigned 10 and printed in console log. After printing, no more commands to run, so a() local EC is removed from both GEC and from Call stack
            </li>
            
            <p>Call Stack: GEC</p>
            
            <li>
              Cursor goes back to b() function call. Same steps repeat.
            </li>
            
            <p>Call Stack :[GEC, b()] -> GEC (after printing yet another totally different x value as 100 in console log</p>
            
            <li>
              Finally GEC is deleted and also removed from call stack. Program ends.
            </li>
            
            <li>
               Reference:
            </li>
          </ul>
          
          <a href="https://youtu.be/gSDncyuGw0s?t=256" target="_blank"><img class="image" src="https://i.postimg.cc/kg5M9nMm/Functions-and-Variable-Environments.png" alt="Functions-and-Variable-Environments"/></a>
  <!--         img -->
        </article>
      </section>
      
      <section class="main-section" id="Shortest_JS_Program,_window_&_this_keyword">
        <header>Shortest JS Program, window & this keyword</header>
        <article>
          <ul>
            <li>
              The shortest JS program is empty file. Because even then, JS engine does a lot of things. As always, even in this case, it creates the GEC which has memory space and the execution context.
            </li>
            
            <li>
              JS engine creates something known as 'window'. It is an object, which is created in the global space. It contains lots of functions and variables. These functions and variables can be accessed from anywhere in the program. JS engine also creates a this keyword, which points to the window object at the global level. So, in summary, along with GEC, a global object (window) and a this variable are created.
            </li>
            
            <li>
              In different engines, the name of global object changes. Window in browsers, but in nodeJS it is called something else. At global level, this === window
            </li>
            
            <li>
              If we create any variable in the global scope, then the variables get attached to the global object.
            </li>
          <code
            >var x = 10;
            console.log(x); // 10
            console.log(this.x); // 10
            console.log(window.x); // 10
          </code>
          </ul>
        </article>
      </section>
      
      <section class="main-section" id="Undefined_vs_not_defined_in_JS">
        <header>Undefined vs not defined in JS</header>
        <article>
          <ul>
            <li>
              In first phase (memory allocation) JS assigns each variable a placeholder called undefined.
            </li>
            
            <li>
              <b>Undefined</b> is when memory is allocated for the variable, but no value is assigned yet.
            </li>
            
            <li>
              If an object/variable is not even declared/found in memory allocation phase, and tried to access it then it is <b>Not defined</b>.
            </li>
            
            <li>
              Not Defined !== Undefined
            </li>
          </ul>
          
          <p>
            When variable is declared but not assigned value, its current value is <b>undefined</b>. But when the variable itself is not declared but called in code, then it is <b>not defined</b>.
          </p>
          
          <code
            >console.log(x); // undefined
            var x = 25;
            console.log(x); // 25
            console.log(a); // Uncaught ReferenceError: a is not defined.
          </code>
          
          <ul>
            <li>
              JS is a loosely typed / weakly typed language. It doesn't attach variables to any datatype. We can say var a = 5, and then change the value to boolean a = true or string a = 'hello' later on.
            </li>
            
            <li>
              Never assign undefined to a variable manually. Let it happen on it's own accord.
            </li>
          </ul>
        </article>
      </section>
      
      <section class="main-section" id="The_Scope_Chain,_Scope_&_Lexical_Environment">
        <header>The Scope Chain, Scope & Lexical Environment</header>
        <article>
          <ol>
            Scope means where you can access variable or a function in a code.
            <b>Two aspects:</b>
            <li>
              What is the scope of this variable b(where can I access this variable b)
            </li>
            
            <li>
              b is inside the scope
            </li> 
          </ol>
          
          <ul>
            <li>
              Scope in Javascript is directly related to Lexical Environment.  
            </li>
            
            <li>
              Let's observe the below examples:
            </li>
          </ul>
          <code
            >// CASE 1
            function a() {
            console.log(b); // 10
            // Instead of printing undefined it prints 10, So somehow this a
            function could access the variable b outside the function scope. 
            }
            var b = 10;
            a();
          </code>
          
          <code
            >// CASE 2
            function a() {
             c();
             function c() {
             console.log(b); // 10
             }
            }
            var b = 10;
            a();
          </code>
          
          <code
            >// CASE 3
            function a() {
             c();
             function c() {
             var b = 100;
             console.log(b); // 100
             }
            }
            var b = 10;
            a();
          </code>
          
          <code          
            >// CASE 4
            function a() {
             var b = 10;
             c();
             function c() {
             console.log(b); // 10
             }
            }
            a();
            console.log(b); // Error, Not Defined
          </code>
          
          <ul>
            <li>Let's try to understand the output in each of the cases above.</li>
            
            <ul>
              <li>
                In case 1: function a is able to access variable b from Global scope.
              </li>
              
              <li>
                In case 2: 10 is printed. It means that within nested function too, the global scope variable can be accessed.
              </li>
              
              <li>
                In case 3: 100 is printed meaning local variable of the same name took precedence over a global variable.
              </li>
              
              <li>
                In case 4: A function can access a global variable, but the global execution context can't access any local variable.
              </li>
            </ul>
          </ul>
          
          <code
            >To summarize the above points in terms of execution context:
            call_stack = [GEC, a(), c()]
            Now lets also assign the memory sections of each execution
            context in call_stack.
            c() = [[lexical environment pointer pointing to a()]]
            a() = [b:10, c:{}, [lexical environment pointer pointing to GEC]]
            GEC = [a:{},[lexical_environment pointer pointing to null]]
          </code>
          
          <a href="https://youtu.be/uH-tVP8MUs8?t=523" target="_blank"><img class="image" src="https://i.postimg.cc/ZYFJd9Cm/The-Scope-Chain-Scope-Lexical-Environment-1.png" alt="The-Scope-Chain-Scope-Lexical-Environment-1"/></a>
          
  <!--         img -->
          
          <a href="https://youtu.be/uH-tVP8MUs8?t=927" target="_blank"><img class="image" src="https://i.postimg.cc/pXWRY2FF/The-Scope-Chain-Scope-Lexical-Environment-2.png" alt="The-Scope-Chain-Scope-Lexical-Environment-2"/></a>
  <!--         img -->
          
          <ul>
            <li>
              So, <b>Lexical Environment</b> = local memory + lexical env of its parent. Hence, Lexical Environement is the local memory along with the lexical environment of its parent.
            </li>
            
            <li>
              <b>Lexical</b>: In hierarchy, In order
            </li>
            
            <li>
              Whenever an Execution Context is created, a Lexical environment(LE) is also created and is referenced in the local Execution Context(in memory space).
            </li>
            
            <li>
              The process of going one by one to parent and checking for values is called scope chain or Lexcial environment chain.
            </li>
            
            <li>
              <code>function a() {
               function c() {
               // logic here
               }
               c(); // c is lexically inside a
              } // a is lexically inside global execution
              </code>
            </li>
            
            <li>
              Lexical or Static scope refers to the accessibility of variables, functions and object based on phylical location in source code
              <code>Global {
                Outer {
                Inner
                }
                }
                // Inner is surrounded by lexical scope of Outer
              </code>
            </li>
            
            <li>
              <b>TLDR</b>; An inner function can access variables which are in outer functions even if inner function is nested deep. In any other case, a function can't access variables not in its scope.
            </li>
          </ul>
        </article>
      </section>
      
      <section class="main-section" id="let_&_const_in_JS,_Temporal_Dead_Zone">
        <header>let & const in JS, Temporal Dead Zone</header>
        <article>
          <ul>
            <li>
              let and const declarations are hoisted. But its different from var
            </li>
            <code
              >console.log(a); // ReferenceError: Cannot access 'a' before initialization
                console.log(b); // prints undefined as expected
                let a = 10;
                console.log(a); // 10
                var b = 15;
                console.log(window.a); // undefined
                console.log(window.b); // 15
            </code>
            It looks like let isn't hoisted, but it is, let's understand
            
            <li>
              Both a and b are actually initialized as undefined in hoisting stage. But var b is inside the storage space of GLOBAL, and a is in a separate memory object called script, where it can be accessed only after assigning some value to it first ie. one can access 'a' only if it is assigned. Thus, it throws error
            </li>
            
            <li>
              <b>Temporal Dead Zone</b> : Time since when the let variable was hoisted until it is initialized some value.
              
              <ul>
                <li>
                  So any line till before "let a = 10" is the TDZ for a
                </li>
                
                <li>
                  Since a is not accessible on global, its not accessible in window/this also. window.b or this.b -> 15; But window.a or this.a ->undefined, just like window.x->undefined (x isn't declared anywhere)
                </li>
              </ul>      
            </li>
            
            <li>
              <b>Reference Error</b> are thrown when variables are in temporal dead zone.
            </li>
            
            <li>
              <b>Syntax Error</b> doesn't even let us run single line of code.
            </li>
            
            <code>let a = 10;
              let a = 100; //this code is rejected upfront as SyntaxError. (duplicate
              declaration)
              ------------------
              let a = 10;
              var a = 100; // this code also rejected upfront as SyntaxError. (can't use
              same name in same scope)
            </code>
            <li>
              <b>Let</b> is a stricter version of <b>var</b>. Now, <b>const</b> is even more stricter than <b>let</b>.
            </li>
            
            <code>let a;
              a = 10;
              console.log(a) // 10. Note declaration and assigning of a is in different
              lines.
              ------------------
              const b;
              b = 10;
              console.log(b); // SyntaxError: Missing initializer in const declaration.
              (This type of declaration won't work with const. const b = 10 only will
              work)
              ------------------
              const b = 100;
              b = 1000; //this gives us TypeError: Assignment to constant variable.
            </code>
            
            <li>
              Types of <b>Error</b>: Syntax, Reference, and Type.
              
              <ul>
                <li>
                  Uncaught ReferenceError: x is not defined at ...
                  
                  <ul><li>This Error signifies that x has never been in the scope of the program. This literally means that x was never defined/declared and is being tried to be accesed.</li></ul>
                </li>
                
                <li>
                  Uncaught ReferenceError: cannot access 'a' before initialization
                  <ul><li>This Error signifies that 'a' cannot be accessed because it is declared as 'let' and since it is not assigned a value, it is its Temporal Dead Zone. Thus, this error occurs.</li></ul>
                </li>
                
                <li>
                  Uncaught SyntaxError: Identifier 'a' has already been declared
                  <ul><li>This Error signifies that we are redeclaring a variable that is 'let' declared. No execution will take place.</li></ul>
                </li>
                
                <li>
                  Uncaught SyntaxError: Missing initializer in const declaration
                  <ul><li>This Error signifies that we haven't initialized or assigned value to a const declaration.</li></ul>
                </li>
                
                <li>
                  Uncaught TypeError: Assignment to constant variable
                  
                  <ul><li>This Error signifies that we are reassigning to a const variable.</li></ul>
                </li>
              </ul>
            </li>
            
            <p style="font-weight: bold; font-style: italic;">SOME GOOD PRACTICES:</p>
            <li>
              Try using const wherever possible.
            </li>
            
            <li>
               If not, use let, Avoid var.
            </li>
            
            <li>
              Declare and initialize all variables with let to the top to avoid errors to shrink temporal dead zone window to zero.
            </li>
          </ul>
        </article>
      </section>
      
      <section class="main-section" id="Block_Scope_&_Shadowing_in_JS">
        <header>Block Scope & Shadowing in JS</header>
        <article>
          <p>What is a <b>Block?</b></p>
          <li>Block aka compound statement is used to group JS statements together into 1 group. We group them within {...}
          </li>
          <code> var a = 10;
            let b = 20;
            const c = 30;
            // Here let and const are hoisted in Block scope,
            // While, var is hoisted in Global scope.
            }
          </code>
  
          <li>
            Block Scope and its accessibility example
          </li>
          <code>{
            var a = 10;
            let b = 20;
            const c = 30; }
            console.log(a); // 10
            console.log(b); // Uncaught ReferenceError: b is not defined
          </code>
          <code>* Reason?
            * In the BLOCK SCOPE; we get b and c inside it initialized as
            *undefined* as a part of hoisting (in a seperate memory space called
            **block**)
            * While, a is stored inside a GLOBAL scope. 
            * Thus we say, *let* and *const* are BLOCK SCOPED. They are stored in
            a separate mem space which is reserved for this block. Also, they can't be
            accessed outside this block. But var a can be accessed anywhere as it is
            in global scope. Thus, we can't access them outside the Block.
          </code>
          
          <p>What is <b>Shadowing?</b></p>
          
          <code>var a = 100; {
   var a = 10; // same name as global var
   let b = 20;
   const c = 30;
   console.log(a); // 10
            console.log(b); // 20
   console.log(c); // 30 
  }
  console.log(a); // 10, instead of the 100 we were expecting. So block "a"
  modified val of global "a" as well. In console, only b and c are in block
  space. a initially is in global space(a = 100), and when a = 10 line is
  run, a is not created in block space, but replaces 100 with 10 in global
  space itself.
          </code>
          
          <ul>
            <li>
              So, If one has same named variable outside the block, the variable inside the block shadows the outside variable. This happens only for var.
            </li>
            
            <li>
              Let's observe the behaviour in case of let and const and understand it's reason.
            </li>
          </ul>
          
          <code>let b = 100; {
   var a = 10;
   let b = 20;
   const c = 30;
   console.log(b); // 20
  }
  console.log(b); // 100, Both b's are in separate spaces (one in Block(20)
  and one in Script(another arbitrary mem space)(100)). Same is also true
  for *const* declarations.
          </code>
          
          <a href="https://youtu.be/lW_erSjyMeM?t=481" target="_blank"><img class="image" src="https://i.postimg.cc/4yb44yhJ/Block-Scope-Shadowing-in-JS.png" alt="Block-Scope-Shadowing-in-JS"/></a>
  <!--         img -->
          
          <li>
            Same logic is true even for <b>functions</b>
          </li>
          
          <code>const c = 100;
            function x() {
             const c = 10;
             console.log(c); // 10
            }
            x();
            console.log(c); // 100
          </code>
          
          <li>
            What is <b>Illegal Shadowing?</b>
          </li>
          
          <code>let a = 20; {
   var a = 20; }
  // Uncaught SyntaxError: Identifier 'a' has already been declared
          </code>
          
          <ul>
            <li>
              We cannot shadow let with var. But it is valid to shadow a let using a let. However, we can shadow var with let.
            </li>
            
            <li>
              All scope rules that work in function are same in arrow functions too.
            </li>
            
            <li>
              All scope rules that work in function are same in arrow functions too.
            </li>
          </ul>
  
          <code>let a = 20;
            function x() {
            var a = 20; }
          </code>
        </article>
      </section>
      
      <section class="main-section" id="Closures_in_JS">
        <header>Closures in JS</header>
        <article>
          
          <ul>
            <li>
              Function bundled along with it's lexical scope is closure.
            </li>
            
            <li>
              JavaScript has a lexcial scope environment. If a function needs to access a variable, it first goes to its local memory. When it does not find it there, it goes to the memory of its lexical parent. See Below code, Over here function y along with its lexical scope i.e. (function x) would be called a closure.
            </li>
            
            <code>function x() {
   var a = 7;
   function y() {
   console.log(a);
   }
   return y;  //return y as function it comes along with it's lexical               scope and a in function doesn't refer to the value but a                as reference which is return
  }
  var z = x();
  console.log(z); // value of z is entire code of function y.
            </code>
            <ul>
              <li>
                In above code, When y is returned, not only is the function returned but the entire closure (fun y + its lexical scope) is returned and put inside z. So when z is used somewhere else in program, it still remembers var a inside x()
              </li>
            </ul>
          </ul>
          
          <li>Thus In simple words, we can say:
            <ul>
              <li>
                A closure is a function that has access to its outer function scope even after the function has returned. Meaning, A closure can remember and access variables and arguments reference of its outer function even after the function has returned.
              </li>
            </ul>
          </li>
          
          <a href="https://youtu.be/qikxEIxsXco?t=108" target="_blank"><img class="image" src="https://i.postimg.cc/8PNPKRqs/Closures-in-JS.png" alt="Closures-in-JS"/></a>
  <!--         img -->
          
          <ul>
            <li>
              Advantages of Closure:
            </li>
            <ul>
              <li>
                Module Design Pattern
              </li>
              
              <li>
                 Currying
              </li>
              
              <li>
                 Memoize 
              </li>
              
              <li>
                Data hiding and encapsulation
              </li>
              
              <li>
                setTimeouts etc.
              </li>
            </ul>
            <li>Uses of Clouser
                <ul>
                  <li>
                    Functions like once( you can use only once )
                  </li>
                  
                  <li>
                    maintaining state in asyns world
                  </li>
                  
                  <li>
                    Iterators
                  </li>
                </ul>
              </li>
          </ul>
          
          <ul>
            <li>
              Disadvantages of Closure:
            </li>
            <ul>
              <li>
                 Over consumption of memory 
              </li>
              
              <li>
                Memory Leak 
              </li>
              
              <li>
                Freeze browser
              </li>
            </ul>
          </ul>
        </article>
      </section>
      
      <section class="main-section" id="setTimeout_+_Closures_Interview_Question">
        <header>setTimeout + Closures Interview Question</header>
        <article>
          <p>Time, tide and Javascript wait for none.</p>
          
          <code>function x() {
            var i = 1;
            setTimeout(function() {
            console.log(i);
            }, 3000);
            console.log("Javascript");
            }
            x();
            // Output:
            // Javascript
            // 1 // after waiting
          </code>
          
          <ul>
            <li>
              We expect JS to wait 3 sec, print 1 and then go down and print the string. But JS prints string immediately, waits 3 sec and then prints 1.
            </li>
            
            <li>
              The function inside setTimeout forms a closure (remembers reference to i). So wherever function goes it carries this ref along with it.
            </li>
            
            <li>
              setTimeout takes this callback function & attaches timer of 3000ms and stores it. Goes to next line without waiting and prints string.
            </li>
            
            <li>
              After 3000ms runs out, JS takes function, puts it into call stack and runs it.
            </li>
            
            <li>
              Q: Print 1 after 1 sec, 2 after 2 sec till 5 : Tricky interview question
              <br>We assume this has a simple approach as below
              
              <code>function x() {
                for(var i = 1; i<=5; i++){
                 setTimeout(function() {
                 console.log(i);
                 }, i*1000);
                 }
                 console.log("Namaste Javascript");
                }
                x();
                // Output:
                // Namaste Javascript
                // 6
                // 6
                // 6
                // 6
                // 6
              </code>
                
                <ul>
                  <li>Reason?</li>
                  <ul>
                    <li>
                      This happens because of closures. When setTimeout stores the function somewhere and attaches timer to it, the function remembers its reference to i, not value of i. All 5 copies of function point to same reference of i. JS stores these 5 functions, prints string and then comes back to the functions. By then the timer has run fully. And due to looping, the i value became 6. And when the callback fun runs the variable i = 6. So same 6 is printed in each log
                    </li>
                    
                    <li>
                      To avoid this, we can use let instead of var as let has Block scope. For each iteration, the i is a new variable altogether(new copy of i). Everytime setTimeout is run, the inside function forms closure with new variable i
                    </li>
                  </ul>
                  
                  <li>But what if interviewer ask us to implement using var?</li>
                  <code>function x() {
                     for(var i = 1; i<=5; i++){
                     function close(i) {
                     setTimeout(function() {
                     console.log(i);
                     }, i*1000);
                  </code>
                </ul>
            </li>
          </ul>
        </article>
      </section>
      
      <section class="main-section" id="Famous_Interview_Questions_ft._Closures">
        <header>Famous Interview Questions ft. Closures</header>
        <article>
          <p>Q1: What is Closure in Javascript?</p>
          <p>
            <b>Ans</b>: A function along with reference to its outer environment together forms a closure. Or in other words, A Closure is a combination of a function and its lexical scope bundled together. eg:
  
            <code>function outer() {
              var a = 10;
              function inner() {
              console.log(a);
              } // inner forms a closure with outer
              return inner;
              }
              outer()(); // 10 // over here first `()` will return inner function and
              then using second `()` to call inner function
            </code>
          </p>
  
          <p>Q2: Will the below code still forms a closure?</p>
          <p>
            <code>function outer() {
              function inner() {
              console.log(a);
              }
              var a = 10;
              return inner;
              }
              outer()(); // 10
            </code>
            <b>Ans:</b> Yes, because inner function forms a closure with its outer environment so sequence doesn't matter.
          </p>
  
          <p>Q3: Changing var to let, will it make any difference?</p>
          <p>
            <code>function outer() {
              let a = 10;
              function inner() {
              console.log(a);
              }
              return inner;
              }
              outer()(); // 10
            </code>
            <br>Ans</br>: It will still behave the same way.
        </p>
  
        <p>Q4: Will inner function have the access to outer function argument?</p>
        <p>
          <code>function outer(str) {
            let a = 10;
            function inner() {
            console.log(a, str);
            }
            return inner;
            }
            outer("Hello There")(); // 10 "Hello There"
          </code>
          <b>Ans</b>: Inner function will now form closure and will have access to both a and b.
        </p>
  
        <p>Q5: In below code, will inner form closure with outest?</p>
        <p>
          <code>function outest() {
            var c = 20;
            function outer(str) {
            let a = 10;
            function inner() {
            console.log(a, c, str);
            }
            return inner;
            }
            return outer;
            }
            outest()("Hello There")(); // 10 20 "Hello There"
          </code>
          <b>Ans</b>: Yes, inner will have access to all its outer environment.
        </p>
  
        <p>Q6: Output of below code and explaination?</p>
        <p>
          <code>function outest() {
            var c = 20;
            function outer(str) {
            let a = 10;
            function inner() {
            console.log(a, c, str);
            }
            return inner;
            }
            return outer;
            }
            let a = 100;
            outest()("Hello There")(); // 10 20 "Hello There"
          </code>
          <b>Ans</b>: Still the same output, the inner function will have reference to inner a, so conflicting name won't matter here. If it wouldn't have find a inside outer function then it would have went more outer to find a and thus have printed 100. So, it try to resolve variable in scope chain and if a wouldn't have been found it would have given reference error.
        </p>
  
        <p>Q7: Advantage of Closure?</p>
        <p>
        <ul>
          <li>
            Module Design Pattern
          </li>
  
          <li>
            Currying
          </li>
  
          <li>
            Memoize 
          </li>
  
          <li>
            Data hiding and encapsulation
          </li>
  
          <li>
            setTimeouts etc.
          </li>
        </ul>
        </p>
  
      <p>Q8: Discuss more on Data hiding and encapsulation?</p>
      <p>
        <code>// without closures
          var count = 0;
          function increment(){
          count++;
          }
          // in the above code, anyone can access count and change it. 
          ------------------------------------------------------------------
          // (with closures) -> put everything into a function
          function counter() {
          var count = 0;
          function increment(){
          count++;
          }
          }
          console.log(count); // this will give referenceError as count can't be
          accessed. So now we are able to achieve hiding of data
          ------------------------------------------------------------------
          //(increment with function using closure) true function
          function counter() {
          var count = 0;
          return function increment(){
          count++;
          console.log(count);
          }
          }
          var counter1 = counter(); //counter function has closure with count var. 
          counter1(); // increments counter
          var counter2 = counter();
          counter2(); // here counter2 is whole new copy of counter function and it
          wont impack the output of counter1
          *************************
          // Above code is not good and scalable for say, when you plan to implement
          decrement counter at a later stage. 
          // To address this issue, we use *constructors*
          // Adding decrement counter and refactoring code:
          function Counter() {
          //constructor function. Good coding would be to capitalize first letter of
          constructor function.
          var count = 0;
          this.incrementCounter = function() { //anonymous function
          count++;
          console.log(count);
          }
          this.decrementCounter = function() {
          count--;
          console.log(count);
          }
          }
          var counter1 = new Counter(); // new keyword for constructor fun
          counter1.incrementCounter();
          counter1.incrementCounter();
          counter1.decrementCounter();
          // returns 1 2 1
        </code>
      </p>
  
      <p>Q9: Disadvantage of closure?</p>
      <p>
        <b>Ans</b>: Overconsumption of memory when using closure as everytime as those closed over variables are not garbage collected till program expires. So when creating many closures, more memory is accumulated and this can create memory leaks if not handled.
        <br>
        <b>Garbage collector</b> : Program in JS engine or browser that frees up unused memory. In highlevel languages like C++ or JAVA, garbage collection is left to the programmer, but in JS engine its done implicitly
  
        <code>function a() {
          var x = 0;
          return function b() {
          console.log(x);
          }
          }
          var y = a(); // y is a copy of b()
          y(); 
          // Once a() is called, its element x should be garbage collected ideally.
          But fun b has closure over var x. So mem of x cannot be freed. Like this
          if more closures formed, it becomes an issue. To tacke this, JS engines
          like v8 and Chrome have smart garbage collection mechanisms. Say we have
          var x = 0, z = 10 in above code. When console log happens, x is printed as
          0 but z is removed automatically.
        </code>
      </p>
        </article>
      </section>
      
      <section class="main-section" id="First_Class_Functions_ft._Anonymous_Functions">
        <header>First Class Functions ft. Anonymous Functions</header>
        <article>
          <p class="heading_pro">Functions are heart ♥ of Javascript</p> 
          
          <p>Q: What is Function statement?</p>
          <p>
            Below way of creating function are function statement.
            
            <code>function a() {
   console.log("Hello");
  }
  a(); // Hello
            </code>
          </p>
          
          <p>Q: What is Function Expression?</p>
          <p>
            Assigning a function to a variable. Function acts like a value.
            <code>var b = function() {
   console.log("Hello");
  }
  b();
            </code>
          </p>
          
          <p>Q: Difference between function statement and expression</p>
          <p>The major difference between these two lies in <b>Hoisting</b>.
            <code>a(); // "Hello A"
  b(); // TypeError
  function a() {
   console.log("Hello A");
  }
  var b = function() {
   console.log("Hello B");
  }
  // Why? During mem creation phase a is created in memory and function
  assigned to a. But b is created like a variable (b:undefined) and until
  code reaches the function() part, it is still undefined. So it cannot be
  called.
            </code>
          </p>
          
          <p>Q: What is Function Declaration?</p>
          <p>Other name for <b>function statement</b>.</p>
          
          <p>Q: What is Anonymous Function?</p>
          <p>
            A function without a name.
            
            <code>function () { }// this is going to throw Syntax Error - Function Statement requires
  function name.
            </code>
            
            <ul>
              <li>They don't have their own identity. So an anonymous function without code inside it results in an error.
              </li>
              
              <li> Anonymous functions are used when functions are used as values eg. the code sample for function expression above.
              </li>
            </ul>
          </p>
        
        <p>Q: What is Named Function Expression?</p>
        <p>
          Same as Function Expression but function has a name instead of being anonymous.
          <code>var b = function xyz() {
   console.log("b called");
  }
  b(); // "b called"
  xyz(); // Throws ReferenceError:xyz is not defined.
  // xyz function is not created in global scope. So it can't be called.
          </code>
        </p>
            
            <p>Q: Parameters vs Arguments?</p>
            <p>
              <code>var b = function(param1, param2) { // labels/identifiers are parameters
   console.log("b called");
  }
  b(arg1, arg2); // arguments - values passed inside function call
              </code>
            </p>
            
            <p>Q: What is First Class Function aka First Class Citizens?</p>
            <p>
              We can pass functions inside a function as arguments and /or return a function(HOF). These ability are altogether known as First class function. It is programming concept available in some other languages too.
              
              <code>var b = function(param1) {
   console.log(param1); // prints " f() {} "
  }
  b(function(){});
  // Other way of doing the same thing:
  var b = function(param1) {
   console.log(param1);
  }
  function xyz(){ }
  b(xyz); // same thing as prev code
  // we can return a function from a function:
  var b = function(param1) {
   return function() {
   } 
  }
  console.log(b()); //we log the entire fun within b.
              </code>
            </p>
            
        </article>
      </section>
      
      <section class="main-section" id="Callback_Functions_in_JS_ft._Event_Listeners">
        <header>Callback Functions in JS ft. Event Listeners</header>
        <article>
  <p>Callback Functions</p>
          <li>Functions are first class citizens ie. take a function A and pass it to another function B. Here, A is a callback function. So basically we are giving access to function B to call function A. This callback function gives us the access to whole Asynchronous world in Synchronous world.</li>
          
          <code>setTimeout(function () {
   console.log("Timer");
  }, 1000) // first argument is callback function and second is timer.
          </code>
          
          <li>JS is a synchronous and single threaded language. But due to callbacks, we can do async things in JS.</li>
          
          <code>setTimeout(function () {
  console.log("timer");
  }, 5000);
  function x(y) {
  console.log("x");
  y();
  }
  x(function y() {
  console.log("y");
  });
  // x y timer
          </code>
          
          <ul>
            <li>In the call stack, first x and y are present. After code execution, they go away and stack is empty. Then after 5 seconds (from beginning) anonymous suddenly appear up in stack ie. setTimeout
            </li>
            
            <li>
              All 3 functions are executed through call stack. If any operation blocks the call stack, its called blocking the main thread
            </li>
            
            <li>
              Say if x() takes 30 sec to run, then JS has to wait for it to finish as it has only 1 call stack/1 main thread. Never block main thread.
            </li>
            
            <li>
              Always use async for functions that take time eg. setTimeout
            </li>
            
            <code>// Another Example of callback
  function printStr(str, cb) {
   setTimeout(() => {
   console.log(str);
   cb();
   }, Math.floor(Math.random() * 100) + 1) }
  function printAll() {
   printStr("A", () => {
   printStr("B", () => {
   printStr("C", () => {})
   })
   })
  }
  printAll() // A B C // in order
            </code>
          </ul>
          
          <p>Event Listener</p>
          <ul>
            <li>
              We will create a button in html and attach event to it.
            </li>
            
            <code>// index.html
  <button id="clickMe">Click Me!</button>
  // in index.js
  document.getElementById("clickMe").addEventListener("click", function
  xyz(){ //when event click occurs, this callback function (xyz) is called
  into callstack
              console.log("Button clicked");
  });
            </code>
            
            <li>
              Lets implement a increment counter button.
              <ul>
                <li>
                  Using global variable (not good as anyone can change it)
                  
                <code>let count = 0;
  document.getElementById("clickMe").addEventListener("click",
  function xyz(){ 
   console.log("Button clicked", ++count);
  });
                </code>
                </li>
                
                <li>
                  Use closures for data abstraction
                  
                  <code>function attachEventList() { //creating new function for closure
   let count = 0;
   document.getElementById("clickMe").addEventListener("click",
  function xyz(){ 
   console.log("Button clicked", ++count); //now callback
  function forms closure with outer scope(count)
  });
  }
  attachEventList();
                  </code>
                </li>
              </ul>
            </li>
          </ul>
          
          <a href="https://youtu.be/btj35dh3_U8" target="_blank"><img class="image" src="https://i.postimg.cc/VsjkWGZ3/Callback-Functions-in-JS-ft-Event-Listeners.png" alt="Callback-Functions-in-JS-ft-Event-Listeners"/></a>
          
  <!--         img -->
          
          <p>Garbage Collection and removeEventListeners</p>
          
          <li>
            Event listeners are heavy as they form closures. So even when call stack is empty, EventListener won't free up memory allocated to count as it doesn't know when it may need count again. So we remove event listeners when we don't need them (garbage collected) onClick, onHover, onScroll all in a page can slow it down heavily.
          </li>
        </article>
      </section>
      
      <section class="main-section" id="Asynchronous_JavaScript_&_EVENT_LOOP_from_scratch">
        <header>Asynchronous JavaScript & EVENT LOOP from scratch</header>
        <article>
          <p class="heading_pro">
            Note: Call stack will execeute any execeution context which enters it. Time, tide and JS waits for none. TLDR; Call stack has no timer.
          </p>
          
          <ul>
            
            <li>
              Browser has JS Engine which has Call Stack which has Global execution context, local execution context etc.
            </li>
            
            <ul>
              <li>
                But browser has many other superpowers - Local storage space, Timer, place to enter URL, Bluetooth access, Geolocation access and so on
              </li>
              
              <li>
                Now JS needs some way to connect the callstack with all these superpowers. This is done using Web APIs.
              </li>
            </ul>
            
            <a href="https://youtu.be/8zKuNo4ay8E" target="_blank"><img class="image" src="https://i.postimg.cc/WzPbPgzW/Asynchronous-Java-Script-EVENT-LOOP-from-scratch.png" alt="Asynchronous-Java-Script-EVENT-LOOP-from-scratch"/></a>
  <!--           img -->
            
          </ul>
          
          <p class="heading_pro">Web APIs</p>
          <p>None of the below are part of Javascript! These are extra superpowers that browser has. Browser gives access to JS callstack to use these powers.</p>
          
          
          <a href="https://youtu.be/8zKuNo4ay8E" target="_blank"><img class="image" src="https://i.postimg.cc/xd4cBXLh/Asynchronous-Java-Script-EVENT-LOOP-from-scratch-2.png" alt="Asynchronous-Java-Script-EVENT-LOOP-from-scratch-2"/></a>
  <!--         img -->
          
          <ul>
            <li>
              setTimeout(), DOM APIs, fetch(), localstorage, console (yes, even console.log is not JS!!), location and so many more.
            </li>
            
            <ul>
              <li>
                setTimeout() : Timer function
              </li>
              
              <li>
                DOM APIs : eg.Document.xxxx ; Used to access HTML DOM tree. (Document Object Manipulation)
              </li>
              
              <li>
                fetch() : Used to make connection with external servers eg. Netflix servers etc.
              </li>
            </ul>
            
            <li>
              We get all these inside call stack through global object ie. window.
            </li>
            
            <ul>
              <li>
                Use window keyword like : window.setTimeout(), window.localstorage, window.console.log() to log something inside console.
              </li>
              
              <li>
                As window is global obj, and all the above functions are present in global object, we don't explicity write window but it is implied.
              </li>
            </ul>
            
            <li>
              Let's undertand the below code image and its explaination:
              
              <a href="https://youtu.be/8zKuNo4ay8E" target="_blank"><img class="image" src="https://i.postimg.cc/FFc7nszC/Asynchronous-Java-Script-EVENT-LOOP-from-scratch-3.png" alt="Asynchronous-Java-Script-EVENT-LOOP-from-scratch-3"/></a>
  <!--             img -->
              
              <ul>
                <li>
                  <code>console.log("start");
  setTimeout(function cb() {
   console.log("timer");
  }, 5000);
  console.log("end");
  // start end timer
                  </code>
                </li>
                
                <li>
                  First a GEC is created and put inside call stack.
                </li>
                
                <li>
                  console.log("Start"); // this calls the console web api (through window) which in turn actually modifies values in console.
                </li>
                
                <li>
                  setTimeout(function cb() { //this calls the setTimeout web api which gives access to timer feature. It stores the callback cb() and starts timer. console.log("Callback");}, 5000);
                </li>
                
                <li>
                  console.log("End"); // calls console api and logs in console window. After this GEC pops from call stack.
                </li>
                
                <li>
                  While all this is happening, the timer is constantly ticking. After it becomes 0, the callback cb() has to run.
                </li>
                
                <li>
                  Now we need this cb to go into call stack. Only then will it be executed. For this we need <b>event loop</b> and <b>Callback queue</b>.
                </li>
              </ul>
            </li>
          </ul>
          
          <p>Event Loops and Callback Queue</p>
          
          <p>Q: How after 5 secs timer is console?</p>
          
          <ul>
            <li>
              cb() cannot simply directly go to callstack to be execeuted. It goes through the callback queue when timer expires.
            </li>
            
            <li>
              Event loop keep checking the callback queue, and see if it has any element to puts it into call stack. It is like a gate keeper
            </li>
            
            <li>
              Once cb() is in callback queue, eventloop pushes it to callstack to run. Console API is used and log printed
            </li>
            
            <li>
              
              <a href="https://youtu.be/8zKuNo4ay8E" target="_blank"><img class="image" src="https://i.postimg.cc/sgnXZMHx/Asynchronous-Java-Script-EVENT-LOOP-from-scratch-4.png" alt="Asynchronous-Java-Script-EVENT-LOOP-from-scratch-4"/></a>
  <!--           img -->
            
              
            </li>
          </ul>
          
          <p>Q: Another example to understand Eventloop & Callback Queue.</p>
          <p>
            See the below Image and code and try to understand the reason:
            
            <a href='https://youtu.be/8zKuNo4ay8E' target='_blank'><img class="image" src='https://i.postimg.cc/W41Zkvm4/Asynchronous-Java-Script-EVENT-LOOP-from-scratch-4b.png' border='0' alt='Asynchronous-Java-Script-EVENT-LOOP-from-scratch-4b'/></a>
  <!--           img -->
            
            Explaination?
            <ul>
              <li>
                <code>console.log("Start"); 
  document. getElementById("btn").addEventListener("click", function
  cb() { 
   // cb() registered inside webapi environment and event(click)
  attached to it. i.e. REGISTERING CALLBACK AND ATTACHING EVENT TO IT.
              console.log("Callback");
  });
  console.log("End"); // calls console api and logs in console window.
  After this GEC get removed from call stack.
  // In above code, even after console prints "Start" and "End" and pops
  GEC out, the eventListener stays in webapi env(with hope that user may
  click it some day) until explicitly removed, or the browser is closed.
                </code>
              </li>
              
              <li>
                Eventloop has just one job to keep checking callback queue and if found something push it to call stack and delete from callback queue.
              </li>
          </ul>
          </p>
          
          <p>Q: Need of callback queue?</p>
          <p>
            <b>Ans</b>: Suppose user clciks button x6 times. So 6 cb() are put inside callback queue. Event loop sees if call stack is empty/has space and whether callback queue is not empty(6 elements here). Elements of callback queue popped off, put in callstack, executed and then popped off from call stack.
          </p>
        
        <p>Behaviour of fetch (<b>Microtask Queue</b>?)</p>
        <p>
          Let's observe the code below and try to understand
          
          <code>console.log("Start"); // this calls the console web api (through window)
  which in turn actually modifies values in console. 
  setTimeout(function cbT() { 
   console.log("CB Timeout");
  }, 5000);
  fetch("https://api.netflix.com").then(function cbF() {
   console.log("CB Netflix");
  }); // take 2 seconds to bring response
  // millions lines of code
  console.log("End"); 
  Code Explaination:
  * Same steps for everything before fetch() in above code.
  * fetch registers cbF into webapi environment along with existing cbT.
  * cbT is waiting for 5000ms to end so that it can be put inside callback
  queue. cbF is waiting for data to be returned from Netflix servers gonna
  take 2 seconds.
  * After this millions of lines of code is running, by the time millions
  line of code will execute, 5 seconds has finished and now the timer has
  expired and response from Netflix server is ready.
  * Data back from cbF ready to be executed gets stored into something
  called a Microtask Queue.
  * Also after expiration of timer, cbT is ready to execute in Callback
  Queue.
  * Microtask Queue is exactly same as Callback Queue, but it has higher
  priority. Functions in Microtask Queue are executed earlier than Callback
  Queue.
  * In console, first Start and End are printed in console. First cbF goes in callstack and "CB Netflix" is printed. cbF popped from callstack. Next
  cbT is removed from callback Queue, put in Call Stack, "CB Timeout" is
  printed, and cbT removed from callstack.
  * See below Image for more understanding
          </code>
          
          <a href="https://youtu.be/8zKuNo4ay8E" target="_blank"><img class="image" src="https://i.postimg.cc/CKzKCw9N/Asynchronous-Java-Script-EVENT-LOOP-from-scratch-5.png" alt="Asynchronous-Java-Script-EVENT-LOOP-from-scratch-5"/></a>
  <!--         img -->
          <br>
          Microtask Priority Visualization
          <br>
          <a href="https://youtu.be/8zKuNo4ay8E" target="_blank"><img class="image" src="https://i.postimg.cc/x8rqTBxP/Asynchronous-Java-Script-EVENT-LOOP-from-scratch-6.png" alt="Asynchronous-Java-Script-EVENT-LOOP-from-scratch-6"/></a>
  <!--         img -->
          <br>
          <b>What enters the Microtask Queue?</b>
          <ul>
            <li>
              All the callback functions that come through promises go in microtask Queue
            </li>
            
            <li>
              <b>Mutation Observer</b> : Keeps on checking whether there is mutation in DOM tree or not, and if there, then it execeutes some callback function.
            </li>
            
            <li>
              Callback functions that come through promises and mutation observer go inside <b>Microtask Queue</b>
            </li>
            
            <li>
              All the rest goes inside <b>Callback Queue aka. Task Queue</b>.
            </li>
            
            <li>
              If the task in microtask Queue keeps creating new tasks in the queue, element in callback queue never gets chance to be run. This is called <b>starvation</b>
            </li>
          </ul>
        </p>
        
  <p>Some Important Questions</p>
  <p>
    <oL>
      <li>
        <b>When does the event loop actually start ?</b> - Event loop, as the name suggests, is a single-thread, loop that is almost infinite. It's always running and doing its job.
      </li>
      
      <li>
        <b>Are only asynchronous web api callbacks are registered in web api environment?</b> - YES, the synchronous callback functions like what we pass inside map, filter and reduce aren't registered in the Web API environment. It's just those async callback functions which go through all this.
      </li>
      
      <li>
        <b>Does the web API environment stores only the callback function and pushes the same callback to queue/microtask queue?</b> - Yes, the callback functions are stored, and a reference is scheduled in the queues. Moreover, in the case of event listeners(for example click handlers), the original callbacks stay in the web API environment forever, that's why it's adviced to explicitly remove the listeners when not in use so that the garbage collector does its job.
      </li>
      
      <li>
         <b>How does it matter if we delay for setTimeout would be 0ms. Then callback will move to queue without any wait ?</b> - No, there are trust issues with setTimeout() 😅 . The callback function needs to wait until the Call Stack is empty. So the 0 ms callback might have to wait for 100ms also if the stack is busy.
      </li>
    </ol>
  </p>
  
  <p>
    Observation of Eventloop, Callback Queue & Microtask Queue [GiF]
    
    <a href="https://youtu.be/8zKuNo4ay8E" target="_blank"><img class="image" src="https://i.postimg.cc/WzMzDSxc/Asynchronous-Java-Script-EVENT-LOOP-from-scratch-7.png" alt="Asynchronous-Java-Script-EVENT-LOOP-from-scratch-7"/></a>
  
  <!--   img -->
    
    <a href="https://youtu.be/8zKuNo4ay8E" target="_blank"><img class="image" src="https://i.postimg.cc/Nfc5hqrs/Asynchronous-Java-Script-EVENT-LOOP-from-scratch-8.png" alt="Asynchronous-Java-Script-EVENT-LOOP-from-scratch-8"/></a>
  <!--   img -->
    
    <a href="https://youtu.be/8zKuNo4ay8E" target="_blank"><img class="image" src="https://i.postimg.cc/wTQ3gfhh/Asynchronous-Java-Script-EVENT-LOOP-from-scratch-9.png" alt="Asynchronous-Java-Script-EVENT-LOOP-from-scratch-9"/></a>
  <!--   img -->
    
    <a href="https://youtu.be/8zKuNo4ay8E" target="_blank"><img class="image" src="https://i.postimg.cc/Jz70nNqS/Asynchronous-Java-Script-EVENT-LOOP-from-scratch-10.png" alt="Asynchronous-Java-Script-EVENT-LOOP-from-scratch-10"/></a>
  <!--   img -->
    
    <a href="https://youtu.be/8zKuNo4ay8E" target="_blank"><img class="image" src="https://i.postimg.cc/TPF3CZ6X/Asynchronous-Java-Script-EVENT-LOOP-from-scratch-11.png" alt="Asynchronous-Java-Script-EVENT-LOOP-from-scratch-11"/></a>
  <!--   img -->
    
    <a href="https://youtu.be/8zKuNo4ay8E" target="_blank"><img class="image" src="https://i.postimg.cc/85vP3tpf/Asynchronous-Java-Script-EVENT-LOOP-from-scratch-12.png" alt="Asynchronous-Java-Script-EVENT-LOOP-from-scratch-12"/></a>
  <!--   img -->
  
  </p>
  
        </article>
      </section>
      
      <section class="main-section" id="JS_Engine_Exposed,_Google's_V8_Architecture">
        <header>JS Engine Exposed, Google's V8 Architecture</header>
        <article>
          <ul>
            <li>
              JS runs literally everywhere from smart watch to robots to browsers because of Javascript Runtime Environment (JRE).
            </li>
            
            <li>
             JRE is like a big container which has everything which are required to run Javascript code. 
            </li>
            
            <li>
              JRE consists of a JS Engine (❤ of JRE), set of APIs to connect with outside environment, event loop, Callback queue, Microtask queue etc.
            </li>
            
            <li>
              Browser can execute javascript code because it has the Javascript Runtime Environment.
            </li>
            
            <li>
              ECMAScript is a governing body of JS. It has set of rules which are followed by all JS engines like Chakra(Edge), Spidermonkey(Firefox)(first javascript engine created by JS creator himself), v8(Chrome)
            </li>
            
            <li>
              Javascript Engine is not a machine. Its software written in low level languages (eg. C++) that takes in hi-level code in JS and spits out low level machine code.
            </li>
            
            <li>
              Code inside Javascript Engine passes through 3 steps : <b>Parsing</b>, <b>Compilation</b> and <b>Execution</b>.
            </li>
            
            <ol>
              <li>
                <b>Parsing</b> - Code is broken down into tokens. In "let a = 7" -> let, a, =, 7 are all tokens. Also we have a syntax parser that takes code and converts it into an AST (Abstract Syntax Tree) which is a JSON with all key values like type, start, end, body etc (looks like package.json but for a line of code in JS. Kinda unimportant)(Check out astexplorer.net -> converts line of code into AST).
              </li>
              
              <li>
                <b>Compilation</b> - JS has something called Just-in-time(JIT) Compilation - uses both interpreter & compiler. Also compilation and execution both go hand in hand. The AST from previous step goes to interpreter which converts hi-level code to byte code and moves to execeution. While interpreting, compiler also works hand in hand to compile and form optimized code during runtime. <b>Does JavaScript really Compiles?</b> The answer is a loud <b>YES</b>. More info at: <a href="https://github.com/getify/You-Dont-Know-JS/blob/2nd-ed/get-started/ch1.md#whats-in-an-interpretation" target="_blank">Link 1</a>, <a href="https://web.stanford.edu/class/cs98si/slides/overview.html" target="_blank">Link 2</a>, <a href="https://blog.greenroots.info/javascript-interpreted-or-compiled-the-debate-is-over" target="_blank">Link 3</a>. JS used to be only interpreter in old times, but now has both to compile and interpreter code and this make JS a JIT compiled language, its like best of both world.
              </li>
              
              <li>
                <b>Execution</b> - Needs 2 components ie. Memory heap(place where all memory is stored) and Call Stack(same call stack from prev episodes). There is also a garbage collector. It uses an algo called <b>Mark and Sweep</b>.
              </li>
            </ol>
            
            <a href="https://youtu.be/2WJL19wDH68?t=1127" target="_blank"><img class="image" src="https://i.postimg.cc/KjNFSWdj/JS-Engine-Exposed-Google-s-V8-Architecture.png" alt="JS-Engine-Exposed-Google-s-V8-Architecture"/></a>
            <!--         img -->
            
            <li>
              Companies use different JS engines and each try to make theirs the best.
              
              <ul>
                <li>
                  v8 of Google has Interpreter called Ignition, a compiler called Turbo Fan and garbage collector called Orinoco.
                </li>
                
                <li>
                  v8 architecture:
                </li>
                
                
                <img class="image" src="https://i.postimg.cc/GpWbkGFL/JS-Engine-Exposed-Google-s-V8-Architecture-3.png" alt="JS-Engine-Exposed-Google-s-V8-Architecture-3"/>
  <!--               img -->
                
              </ul>
            </li>
          </ul>        
        </article>
      </section>
      
      <section class="main-section" id="Trust_issues_with_setTimeout()">
        <header>Trust issues with setTimeout()</header>
        <article>
          <ul>
            <li>
              setTimeout with timer of 5 secs sometimes does not exactly guarantees that the callback function will execute exactly after 5s.
            </li>
            
            <li>
              Let's observe the below code and it's explaination
              
              <code>console.log("Start");
  setTimeout(function cb() {
  console.log("Callback");
  }, 5000);
  console.log("End");
  // Millions of lines of code to execute
  // o/p: Over here setTimeout exactly doesn't guarantee that the
  callback function will be called exactly after 5s. Maybe 6,7 or even
  10! It all depends on callstack. Why?
              </code>
            </li>
            
            Reason?
            <ul>
              <li>
                First GEC is created and pushed in callstack.
              </li>
              
              <li>
                Start is printed in console
              </li>
              
              <li>
                When setTimeout is seen, callback function is registered into webapi's env. And timer is attached to it and started. callback waits for its turn to be execeuted once timer expires. But JS waits for none. Goes to next line.
              </li>
              
              <li>
                End is printed in console.
              </li>
              
              <li>
                After "End", we have 1 million lines of code that takes 10 sec(say) to finish execution. So GEC won't pop out of stack. It runs all the code for 10 sec.
              </li>
              
              <li>
                But in the background, the timer runs for 5s. While callstack runs the 1M line of code, this timer has already expired and callback fun has been pushed to Callback queue and waiting to pushed to callstack to get executed.
              </li>
              
              <li>
                Event loop keeps checking if callstack is empty or not. But here GEC is still in stack so cb can't be popped from callback Queue and pushed to CallStack. <b>Though setTimeout is only for 5s, it waits for 10s until callstack is empty before it can execute</b> (When GEC popped after 10sec, callstack() is pushed into call stack and immediately executed (Whatever is pushed to callstack is executed instantly).
              </li>
              
              <li>
                This is called as the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop" target="_blank">Concurrency model</a> of JS. This is the logic behind setTimeout's trust issues
              </li>
            </ul>
            
            <li>
              The First rule of JavaScript: Do not block the main thread (as JS is a single threaded(only 1 callstack) language).
            </li>
            
            <li>
              In below example, we are blocking the main thread. Observe Questiona and Output.
              
              <a href='https://youtu.be/nqsPmuicJJc?t=414' target='_blank'><img class="image" src='https://i.postimg.cc/sgdYNqYj/Trust-issues-with-set-Timeout.png' border='0' alt='Trust-issues-with-set-Timeout'/></a>
  <!--             img -->
            </li>
            
            <li>
              setTimeout guarantees that it will take at least the given timer to execute the code.
            </li>
            
            <li>
              JS is a synchronous single threaded language. With just 1 thread it runs all pieces of code. It becomes kind of an interpreter language, and runs code very fast inside browser (no need to wait for code to be compiled) (JIT - Just in time compilation). And there are still ways to do async operations as well.
            </li>
            
            <li>
              What if <b>timeout = 0sec</b>?
              
              <code>console.log("Start");
  setTimeout(function cb() {
  console.log("Callback");
  }, 0);
  console.log("End");
  // Even though timer = 0s, the cb() has to go through the queue.
  Registers calback in webapi's env , moves to callback queue, and
  execute once callstack is empty.
  // O/p - Start End Callback
  // This method of putting timer = 0, can be used to defer a less imp
  function by a little so the more important function(here printing
  "End") can take place
              </code>
            </li>
          </ul>
        </article>
      </section>
      
      <section class="main-section" id="Higher_Order_Functions_ft._Functional_Programming">
        <header>Higher Order Functions ft. Functional Programming</header>
        <article>
          <p>Q: What is Higher Order Function?</p>
          <p>
            <b>Ans</b>: A Higher-order functions are functions that take other functions as arguments or return functions as their results. Eg:
            
            <code>function x() {
   console.log("Hi)";
  };
  function y(x) {
   x();
  };
  y(); // Hi
  // y is a higher order function
  // x is a callback function
            </code>
            
            Let's try to understand how we should approach solution in interview. I have an array of radius and I have to calculate area using these radius and store in an array.<br>
            First Approach:
            
            <code>const radius = [1, 2, 3, 4];
  const calculateArea = function(radius) {
   const output = [];
   for (let i = 0; i < radius.length; i++) {
   output.push(Math.PI * radius[i] * radius[i]);
   } 
   return output;
  }
  console.log(calculateArea(radius));
            </code>
              
              The above solution works perfectly fine but what if we have now requirement to calculate array of circumference. Code now be like
              
              <code>const radius = [1, 2, 3, 4];
  const calculateCircumference = function(radius) {
   const output = [];
   for (let i = 0; i < radius.length; i++) {
   output.push(2 * Math.PI * radius[i]);
   } 
   return output;
  }
  console.log(calculateCircumference(radius));
              </code>
                
                But over here we are violating some principle like DRY Principle, now lets observe the better approach.
                
                <code>const radiusArr = [1, 2, 3, 4];
  // logic to calculate area
  const area = function (radius) {
   return Math.PI * radius * radius;
  }
  // logic to calculate circumference
  const circumference = function (radius) {
   return 2 * Math.PI * radius;
  }
  const calculate = function(radiusArr, operation) {
   const output = [];
   for (let i = 0; i < radiusArr.length; i++) {
   output.push(operation(radiusArr[i]));
   } 
   return output;
  }
  console.log(calculate(radiusArr, area));
  console.log(calculate(radiusArr, circumference));
  // Over here calculate is HOF
  // Over here we have extracted logic into separate functions. This is the
  beauty of functional programming.
  Polyfill of map
  // Over here calculate is nothing but polyfill of map function
  // console.log(radiusArr.map(area)) == console.log(calculate(radiusArr,
  area));
  ***************************************************
  Lets convert above calculate function as map function and try to use. So,
  Array.prototype.calculate = function(operation) {
   const output = [];
   for (let i = 0; i < this.length; i++) {
   output.push(operation(this[i]));
   } 
   return output;
  }
  console.log(radiusArr.calculate(area))
                </code>
          </p>
        </article>
      </section>
      
      <section class="main-section" id="map,_filter_&_reduce">
        <header>map, filter & reduce</header>
        <article>
          <p class="heading_pro">map, filter & reducer are Higher Order Functions.</p>
          <h3>Map function</h3>
          
          <p>
            It is basically used to transform a array. The map() method creates a new array with the results of calling a function for every array element. <br>
            const output = arr.map(function) // this function tells map that what transformation I want on each element of array
            
            <code>const arr = [5, 1, 3, 2, 6];
  // Task 1: Double the array element: [10, 2, 6, 4, 12]
  function double(x) {
  return x * 2; }
  const doubleArr = arr.map(double); // Internally map will run double
              function for each element of array and create a new array and returns it.
  console.log(doubleArr); // [10, 2, 6, 4, 12]
            </code>
            
            <code>// Task 2: Triple the array element
  const arr = [5, 1, 3, 2, 6];
  // Transformation logic
  function triple(x) {
  return x * 3; }
  const tripleArr = arr.map(triple);
  console.log(tripleArr); // [15, 3, 9, 6, 18]
            </code>
            
            <code>// Task 3: Convert array elements to binary
  const arr = [5, 1, 3, 2, 6];
  // Transformation logic:
  function binary(x) {
  return x.toString(2);
  }
  const binaryArr = arr.map(binary);
  // The above code can be rewritten as :
  const binaryArr = arr.map(function binary(x) {
  return x.toString(2);
  }
  // OR -> Arrow function
  const binaryArr = arr.map((x) => x.toString(2));
            </code>
            
            So basically map function is mapping each and every value and transforming it based on given condition.
          </p>
          
          <h3>Filter function</h3>
          
          <p>
            Filter function is basically used to filter the value inside an array. The arr.filter() method is used to create a new array from a given array consisting of only those elements from the given array which satisfy a condition set by the argument method.
            
            <code>const array = [5, 1, 3, 2, 6];
  // filter odd values
  function isOdd (x) {
   return x % 2; }
  const oddArr = array.filter(isOdd); // [5,1,3]
  // Other way of writing the above:
  const oddArr = arr.filter((x) => x % 2);
            </code>
            
            Filter function creates an array and store only those values which evaluates to true.
          </p>
          
          <h3>Reduce function</h3>
          
          <p>
            It is a function which take all the values of array and gives a single output of it. It reduces the array to give a single output.
            
            <code>const array = [5, 1, 3, 2, 6];
  // Calculate sum of elements of array - Non functional programming way
  function findSum(arr) {
   let sum = 0;
   for (let i = 0; i < arr.length; i++) {
   sum = sum + arr[i];
   }
   return sum;
  }
  console.log(findSum(array)); // 17
  // reduce function way
  const sumOfElem = arr.reduce(function (accumulator, current) {
  // current represent the value of array
  // accumulator is used the result from element of array.
  // In comparison to previous code snippet, *sum* variable is
  *accumulator* and *arr[i]* is *current*
  accumulator = accumulator + current;
  return accumulator;
  }, 0); //In above example sum was initialized with 0, so over here
  accumulator also needs to be initialized, so the second argument to reduce
  function represent the initialization value.
  console.log(sumOfElem); // 17
            </code>
              
              <code>// find max inside array: Non functional programming way:
  const array = [5, 1, 3, 2, 6];
  function findMax(arr) {
   let max = 0;
   for(let i = 0; i < arr.length; i++ {
   if (arr[i] > max) {
   max = arr[i]
   }
   }
   return max;
  }
  console.log(findMax(array)); // 6
  // using reduce
  const output = arr.reduce((acc, current) => {
  if (current > acc ) {
  acc = current; 
  }
  return acc;
                }, 0);
  console.log(output); // 6
  // acc is just a label which represent the accumulated value till now,
  // so we can also label it as max in this case
  const output = arr.reduce((max, current) => {
  if (current > max) {
  max= current; 
  }
  return max;
  }, 0);
  console.log(output); // 6
              </code>
                
                <h3>Tricky MAP</h3>
                
                <code>
                  const users = [
  { firstName: "Alok", lastName: "Raj", age: 23 },
  { firstName: "Ashish", lastName: "Kumar", age: 29 },
  { firstName: "Ankit", lastName: "Roy", age: 29 },
  { firstName: "Pranav", lastName: "Mukherjee", age: 50 },
  ];
  // Get array of full name : ["Alok Raj", "Ashish Kumar", ...]
  const fullNameArr = users.map((user) => user.firstName + " " +
  user.lastName);
  console.log(fullNameArr); // ["Alok Raj", "Ashish Kumar", ...]
  ----------------------------------------------------------
  // Get the count/report of how many unique people with unique age are
  there
  // like: {29 : 2, 75 : 1, 50 : 1}
  // We should use reduce, why? we want to deduce some information from the
  array. Basically we want to get a single object as output
  const report = users.reduce((acc, curr) => {
  if(acc[curr.age]) {
  acc[curr.age] = ++ acc[curr.age] ;
  } else {
  acc[curr.age] = 1; }
  }, {})
  console.log(report) // {29 : 2, 75 : 1, 50 : 1}
  Function Chaining
  // First name of all people whose age is less than 30
  const users = [
  { firstName: "Alok", lastName: "Raj", age: 23 },
  { firstName: "Ashish", lastName: "Kumar", age: 29 },
  { firstName: "Ankit", lastName: "Roy", age: 29 },
                  { firstName: "Pranav", lastName: "Mukherjee", age: 50 },
  ];
  // function chaining
  const output = users.filter((user) => user.age < 30).map(user =>
  user.firstName);
  console.log(output); // ["Alok", "Ashish", "Ankit"]
  // Homework challenge: Implement the same logic using reduce
  const output = users.reduce((acc, curr) => {
  if (curr.age < 30) {
  acc.push(curr.firstName)
  }
   return acc;
  }, []);
  console.log(output); // ["Alok", "Ashish", "Ankit"]
                </code>
          </p>
        </article>
      </section>
  </main>
  </main>
</body>
</html>
